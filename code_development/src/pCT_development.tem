#include "../include/code_development.h"
#include "../include/pCT_development.h"

template<typename T> std::string quote_text(T text ){ return std::string("\"") + std::string(text) + std::string("\""); }
template<typename T> std::string echo_cmd(T statement)
{
	#if defined(_WIN32) || defined(_WIN64)
		return std::string(WIN_ECHO_CMD) + std::string(SPACE_STRING) + std::string(statement);
	#else
		return std::string(BASH_ECHO_CMD) + std::string(SPACE_CHAR) + quote_text(statement);
	#endif
}
template<typename T> std::string colored_text(T statement, const char* text_color_code, const char* background_color_code, const char* underlining_coding )
{
	std::string color_encoding = color_encoding_statement(text_color_code, background_color_code, underlining_coding );
	return std::string(color_encoding + std::string(statement)+ std::string(CLOSE_COLOR_ESCAPE_SEQ));
}
template<typename T> std::string echo_statement(T statement, const char* text_color_code, const char* background_color_code, const char* underlining_coding )
{
	std::string in_statement = colored_text(statement, text_color_code, background_color_code, underlining_coding );
	return echo_cmd(in_statement);
}
template<typename T> void print_colored_text(T statement, const char* text_color_code, const char* background_color_code, const char* underlining_coding )
{
	std::string echo_command = echo_statement<T>(statement, text_color_code, background_color_code, underlining_coding );
	system(echo_command.c_str());
}
template<typename T> void print_labeled_value(const char* statement, T value, const char* statement_color_code, const char* value_color_code, const char* background_color_code, const char* underlining_coding )
{
	std::stringstream value_string;
	value_string << value;
	std::string value_string_colored = colored_text(value_string.str(), value_color_code, background_color_code, underlining_coding );
	std::string out_string_colored = std::string(statement) + value_string_colored;
	print_colored_text(out_string_colored, statement_color_code, background_color_code, underlining_coding );
}
template<typename T> void vector_2_disk( const char* filename_base, const char* directory, const char* folder, std::vector<T> data, const int x_max, const int y_max, const int z_max, const bool single_file )
{
	//std::ofstream output_file;
	int elements = data.size();
	int index;
	int num_files = z_max;
	int z_start = 0;
	int z_end = 1;
	if( single_file )
	{
		num_files = 1;
		z_end = z_max;
	}
	for( int file = 0; file < num_files; file++)
	{
		if( num_files == z_max )
			sprintf( __filename, "%s%s/%s_%d.txt", directory, folder, filename_base, file );
		else
			sprintf( __filename, "%s%s/%s.txt", directory, folder, filename_base );
		__output_file.open(__filename);
		for(int z = z_start; z < z_end; z++)
		{
			for(int y = 0; y < y_max; y++)
			{
				for(int x = 0; x < x_max; x++)
				{
					index = x + ( y * x_max ) + ( z * x_max * y_max );
					if( index >= elements )
						break;
					__output_file << data[index] << " ";
				}
				if( index >= elements )
					break;
				__output_file << std::endl;
			}
			if( index >= elements )
				break;
		}
		z_start += 1;
		z_end += 1;
		__output_file.close();
	}
}
template<typename T> void combine_x_slices( const char* filename_base, const char* directory, const char* folder, const int x_max, const int y_max, const int z_max, bool overwrite )
{
	sprintf(__filename, "%s%s%s.txt", directory, folder, filename_base);
	T value;
	std::vector<T>	data;
	std::fstream	outfile(__filename, std::ofstream::out);
	if(outfile.fail() || overwrite  )//|| ( outfile.seekg (0, outfile.end) == 0 )
	{
		cout << "Combining file: " << __filename << endl;// "\n\t of size " << outfile.seekg (0, outfile.end) << endl;
		for( int i = 0; i < z_max; i++)
		{
			sprintf(__filename, "%s%s%s_%d.txt", directory, folder, filename_base, i);
			std::ifstream	file(__filename);
			while(std::getline(file, __line__input))	// Read one line at a time into the variable line:
			{
				__line_sstream << __line__input;
				while(__line_sstream >> value)
					data.push_back(value);
			}
			file.close();
		}
	}
	else
		cout << "File exists and overwriting is off" << endl;
	//vector_2_disk( filename_base, directory, folder, data, x_max, y_max, z_max, true);
}
template<typename B, typename D, typename F> void concat_x_slices( B filename_base, D directory, F folder, const int x_max, const int y_max, const int z_max, bool overwrite )
{
	 //cout<< "concat_x_slices: " << endl;
     //cout<< " " <<filename_base << endl;
     //cout<< " " <<directory << endl;
     //cout<< " " <<folder << endl;
    //sprintf(__filename, "%s%s%s.txt", charify(directory), charify(folder), charify(filename_base));
	//std::ofstream	outfile(__filename, std::ofstream::out);
	//sprintf(__textfile, "%s%s%s.txt", charify<D>(directory), charify<F>(folder), charify<B>(filename_base));
	//sprintf(__textfile, "%s%s%s.txt", charifyB(directory), charifyB(folder), charifyB(filename_base));
	__string = stringify(directory) + stringify(folder)  + stringify(filename_base)  + stringify(".txt");//<std::string,D,F>
    //sprintf(__textfile, "%s.txt", charify(__string));
	//cout<< "__textfile " <<__string.c_str() << endl;
    std::ofstream	outfile(__string.c_str(), std::ofstream::out);
	//sprintf(__textfile, "%s%s%s.txt", charify(directory), charify(folder), charify(filename_base));
	//sprintf(__textfile, "%s%s%s.txt", std::string(directory).c_str(), std::string(folder).c_str(), std::string(filename_base).c_str());
	//cout<< "__textfile " <<__textfile << endl;
    //std::ofstream	outfile(__textfile, std::ofstream::out);
	if( outfile.fail() || overwrite  )
	{
		//cout << "Combining file: " << __textfile << endl;
		cout << "Combining file: " << __string.c_str() << endl;
		for( int i = 0; i < z_max; i++)
		{
			__string = stringify(directory) + stringify(folder)  + stringify(filename_base) + stringify("_") + std::to_string(i)  + stringify(".txt");//<std::string,D,F>
            //sprintf(__textfile, "%s.txt", charify(__string));
            //cout<< "__filename " <<__string.c_str() << endl;
            //return;
            std::ifstream slice_file(__string.c_str());
			//sprintf(__filename, "%s%s%s_%d.txt", charify<D>(directory), charify<F>(folder), charify<B>(filename_base), i);
			//cout<< "__filename " <<__filename << endl;
            //std::ifstream	slice_file(__filename);
			outfile << slice_file.rdbuf();
			slice_file.close();
		}
	}
	else
		cout << "File exists and overwriting is off" << endl;
}
template<typename B, typename D, typename F> void combine_x_n_slices( B filename_base, D directory, F folder, const int iterations, const int x_max, const int y_max, const int z_max, bool overwrite )
//template<typename D> void combine_x_n_slices( const char* filename_base, D directory, const char* folder, const int iterations, const int x_max, const int y_max, const int z_max, bool overwrite )
{
	 //cout<< "combine_x_n_slices: " << endl;
    // cout<< " " <<filename_base << endl;
    // cout<< " " <<directory << endl;
    // cout<< " " <<folder << endl;
    for( int iteration = 0; iteration <= iterations; iteration++)
	{
		//sprintf(__filename, "%s%d", charify<B>(filename_base), iteration);
		__string = stringify(filename_base) + std::to_string(iteration);//<std::string,D,F>
		concat_x_slices( __string, directory, folder, x_max, y_max, z_max, overwrite );//combine_x_slices<T>( __filename, directory, folder, x_max, y_max, z_max, overwrite );
		//concat_x_slices( charify(__string), directory, folder, x_max, y_max, z_max, overwrite );//combine_x_slices<T>( __filename, directory, folder, x_max, y_max, z_max, overwrite );
	}
	exit_program();
}
template<typename B, typename D> void combine_set_x_n_slices( B filename_base, D directory, const int iterations, const int x_max, const int y_max, const int z_max, bool overwrite )
//void combine_set_x_n_slices( const char* filename_base, const char* directory, const int iterations, const int x_max, const int y_max, const int z_max, bool overwrite )
{
            __i=0;
            __line_sstream = ls<D>(directory);
            while(__line_sstream >> __termout)
			{
				//sprintf(__folder, "%s\\", __termout.c_str());
				//cout<< "__termout : " << __termout.c_str() << endl;
				__string = __termout + "\\";
				cout<< __i++ << ": " << __termout << endl;
				combine_x_n_slices( filename_base, directory, __string, iterations, x_max, y_max, z_max, overwrite );
                //exit_program();
			}
}
